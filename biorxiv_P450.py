# biorxiv_gui.py
# -*- coding: utf-8 -*-
"""
GUI ツール：bioRxiv/medRxiv details API → タイトル/抄録を LM Studio (OpenAI互換) に日本語訳 → HTML出力

主な仕様（今回追加・変更点を含む）:
- ディレクトリ構成（ベースディレクトリ直下）:
    ./date/YYYY-MM-DD/<category_slug>/<doidate>/<doino>.html
    ./date/YYYY-MM-DD/date.html
    ./category/<category_slug>/category.html
    ./date/all_date.html  （全日付の索引: date, index, collected）
    ./log/YYYY/MM/all_month.html  （月次索引: date, index, collected）
    ./log/year/all_year.html      （年次索引: YYYY-MM, 月次ログへのリンク）
- <category> は保存時にスラグ化（スペース→アンダーバー、危険文字→ _）。表示は元のカテゴリ名。
- 100件刻み（0, 100, 200, ...）でページングし、messages.total を最初に表示。
- キーワード限定（翻訳前の title + abstract でフィルタ）。カンマ区切り、AND/OR を選択可能。
- 物理ナビボタンを拡充:
    「◀年 ◀月 ◀日 ▶日 ▶月 ▶年」…… これらだけフォント/パディングを大きく（見やすく）
- 期間指定の追加（Day/Week/Month/Year）:
    ・選択した日付から「さかのぼって」日ごとに取得（Day:1, Week:7, Month:30, Year:365）
- 中断操作を2種類に分離:
    ・Stop Now …… 直ちに中断（当日分は処理途中でも終了。部分的に集計/ログは記録）
    ・Stop After This Day …… 現在処理中の日の完了を待って停止
"""

import json
import os
import re
import sys
import threading
import time
import calendar
from datetime import date as ddate, timedelta
from html import escape
from pathlib import Path
from typing import List, Optional, Tuple
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from tkinter.scrolledtext import ScrolledText

# tkcalendar は任意（無ければテキスト入力にフォールバック）
try:
    from tkcalendar import DateEntry
    HAS_TKCALENDAR = True
except Exception:
    HAS_TKCALENDAR = False

try:
    import requests
except Exception:
    raise SystemExit("このスクリプトには 'requests' が必要です。pip install requests を実行してください。")

# =========================
# 設定（GUIから変更可能な既定値）
# =========================
DEFAULT_API_BASE = "https://api.biorxiv.org/details"
DEFAULT_SERVER = "biorxiv"  # ドロップダウンで medrxiv も選択可
LMSTUDIO_API_URL_DEFAULT = "http://127.0.0.1:1234/v1/chat/completions"
LMSTUDIO_MODEL_DEFAULT = "openai/gpt-oss-20b"
LM_TEMPERATURE = 0.2
LM_MAX_RETRY = 2
TIMEOUT_SEC = 60

PERIOD_MAP = {"Day": 1, "Week": 7, "Month": 30, "Year": 365}

# =============
# HTML テンプレ
# =============
HTML_DOC_TPL = """<!doctype html>
<html lang=\"ja\">
<head>
<meta charset=\"utf-8\">
<title>{title}</title>
<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">
<style>
body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans JP', Roboto, 'Hiragino Sans', 'Yu Gothic', 'Meiryo', sans-serif; line-height: 1.65; padding: 1.2rem; }}
h1 {{ font-size: 1.6rem; margin: 0 0 .6rem; }}
h2 {{ font-size: 1.2rem; margin: 1.2rem 0 .4rem; }}
p  {{ margin: .5rem 0; }}
code, pre {{ background: #f6f8fa; }}
.small {{ color: #666; font-size: .9rem; }}
a {{ color: #0366d6; text-decoration: none; }}
a:hover {{ text-decoration: underline; }}
.meta {{ margin:.5rem 0 1rem; color:#333; }}
.table-wrap {{ margin-top: 1.2rem; overflow-x:auto; }}
table {{ border-collapse: collapse; width: 100%; }}
th, td {{ border: 1px solid #ddd; padding: .4rem .5rem; text-align: left; }}
th {{ background: #f3f4f6; }}
.footer {{ margin-top:2rem; font-size:.9rem; color:#666; }}
</style>
</head>
<body>
<article>
  <h1>{title_ja}</h1>
  <div class=\"meta small\">
    <div><strong>原題:</strong> {title_en}</div>
    <div><strong>日付:</strong> {date}　/　<strong>カテゴリ:</strong> {category}　/　<strong>サーバ:</strong> {server}</div>
    <div><strong>DOI:</strong> <a href=\"{doi_1101_url}\" target=\"_blank\" rel=\"noopener\">{doi_1101_url}</a></div>
    <div><strong>DOI (raw):</strong> <a href=\"{doi_url}\" target=\"_blank\" rel=\"noopener\">{doi_raw}</a></div>
    {jats_line}
  </div>

  <h2>抄録（日本語）</h2>
  <p>{abstract_ja}</p>

  <h2>Abstract (Original)</h2>
  <p>{abstract_en}</p>
</article>

<div class=\"footer\">Generated by biorxiv_gui.py</div>
</body>
</html>
"""

HTML_INDEX_TPL = """<!doctype html>
<html lang=\"ja\">
<head>
<meta charset=\"utf-8\">
<title>{title}</title>
<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">
<style>
body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans JP', Roboto, 'Hiragino Sans', 'Yu Gothic', 'Meiryo', sans-serif; line-height: 1.6; padding:1.2rem; }}
h1 {{ font-size: 1.5rem; margin: .2rem 0 1rem; }}
table {{ border-collapse: collapse; width: 100%; }}
th, td {{ border: 1px solid #ddd; padding: .4rem .5rem; text-align: left; }}
th {{ background: #f3f4f6; }}
.small {{ color:#666; font-size:.92rem; }}
a {{ color: #0366d6; text-decoration: none; }}
a:hover {{ text-decoration: underline; }}
</style>
</head>
<body>
<h1>{title}</h1>
<div class=\"small\">{subtitle}</div>
<div class=\"table-wrap\">
<table>
<thead>
<tr>
  {header_cols}
</tr>
</thead>
<tbody>
<!--ROWS-->
</tbody>
</table>
</div>
</body>
</html>
"""

# =============
# ユーティリティ
# =============
def ensure_parent_dir(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)

def write_text(path: Path, text: str) -> None:
    ensure_parent_dir(path)
    path.write_text(text, encoding="utf-8")

def read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8") if path.exists() else ""

def html_escape_or_none(s: Optional[str]) -> str:
    return "" if s is None else escape(str(s))

def slugify_category(cat: Optional[str]) -> str:
    s = (cat or "uncategorized").strip()
    s = s.replace(" ", "_")
    s = re.sub(r"[\/\\]+", "_", s)
    s = re.sub(r"[^\w\.-]", "_", s, flags=re.UNICODE)
    return s or "uncategorized"

def extract_doi_parts(doi: str) -> Tuple[str, str]:
    doi = doi.strip()
    if "/" not in doi:
        raise ValueError(f"Unexpected DOI format: {doi}")
    right = doi.split("/", 1)[1]
    parts = right.split(".")
    if len(parts) < 4:
        raise ValueError(f"Unexpected DOI right part: {right}")
    doidate = ".".join(parts[0:3])
    doino = parts[3]
    return doidate, doino

def doi_to_url(doi: str) -> str:
    return f"https://doi.org/{doi}"

def doi_parts_to_1101_url(doidate: str, doino: str) -> str:
    return f"https://doi.org/10.1101/{doidate}.{doino}"

def make_row_id(date: str, category: str, doidate: str, doino: str) -> str:
    return f"{date}__{category}__{doidate}__{doino}"

def build_index_row(date: str, category_display: str, doidate: str, doino: str,
                    local_href: str, doi_href: str) -> str:
    row_id = make_row_id(date, category_display, doidate, doino)
    cells = [
        escape(doino),
        escape(doidate),
        f'<a href="{escape(local_href)}" target="_blank" rel="noopener">open</a>',
        f'<a href="{escape(doi_href)}" target="_blank" rel="noopener">{escape(doi_href)}</a>',
        escape(category_display),
    ]
    return f'<tr data-rowid="{escape(row_id)}"><td>' + "</td><td>".join(cells) + "</td></tr>\n"

def ensure_index_file(path: Path, title: str, subtitle: str, header_cols: List[str]) -> None:
    if not path.exists():
        html = HTML_INDEX_TPL.format(
            title=escape(title),
            subtitle=escape(subtitle),
            header_cols="".join(f"<th>{escape(h)}</th>" for h in header_cols),
        )
        write_text(path, html)

def append_row_if_absent(index_path: Path, row_html: str, rowid: str) -> None:
    html = read_text(index_path)
    if f'data-rowid="{rowid}"' in html:
        return
    if "<!--ROWS-->" in html:
        html = html.replace("<!--ROWS-->", row_html + "<!--ROWS-->")
    else:
        html = html.replace("</tbody>", row_html + "</tbody>")
    write_text(index_path, html)

def update_all_date_index(base_dir: Path, date: str, collected: int):
    all_index = base_dir / "date" / "all_date.html"
    ensure_index_file(
        all_index,
        title="All Dates Index",
        subtitle="全日付の索引（date, index, collected）",
        header_cols=["date", "index", "collected"],
    )
    rowid = date
    local_href = f"./{date}/date.html"
    row_html = (
        f'<tr data-rowid="{escape(rowid)}">'
        f'<td>{escape(date)}</td>'
        f'<td><a href="{escape(local_href)}" target="_blank" rel="noopener">{escape(local_href)}</a></td>'
        f'<td>{int(collected)}</td>'
        f'</tr>\n'
    )
    append_row_if_absent(all_index, row_html, rowid)

def update_month_log(base_dir: Path, date: str, collected: int):
    y, m, _ = date.split("-")
    month_index = base_dir / "log" / y / m / "all_month.html"
    ensure_index_file(
        month_index,
        title=f"All Dates in {y}-{m}",
        subtitle="当月の索引（date, index, collected）",
        header_cols=["date", "index", "collected"],
    )
    local_href = f"../../../date/{date}/date.html"
    rowid = date
    row_html = (
        f'<tr data-rowid="{escape(rowid)}">'
        f'<td>{escape(date)}</td>'
        f'<td><a href="{escape(local_href)}" target="_blank" rel="noopener">{escape(local_href)}</a></td>'
        f'<td>{int(collected)}</td>'
        f'</tr>\n'
    )
    append_row_if_absent(month_index, row_html, rowid)

def update_year_log(base_dir: Path, date: str):
    y, m, _ = date.split("-")
    year_index = base_dir / "log" / "year" / "all_year.html"
    ensure_index_file(
        year_index,
        title="All Months Index",
        subtitle="年次索引（YYYY-MM, monthly index link）",
        header_cols=["YYYY-MM", "index"],
    )
    ym = f"{y}-{m}"
    local_href = f"../{y}/{m}/all_month.html"
    rowid = ym
    row_html = (
        f'<tr data-rowid="{escape(rowid)}">'
        f'<td>{escape(ym)}</td>'
        f'<td><a href="{escape(local_href)}" target="_blank" rel="noopener">{escape(local_href)}</a></td>'
        f'</tr>\n'
    )
    append_row_if_absent(year_index, row_html, rowid)

# =============
# API 呼び出し
# =============
def load_json_from_url(url: str, timeout: int = TIMEOUT_SEC) -> dict:
    r = requests.get(url, timeout=timeout)
    r.raise_for_status()
    return r.json()

def parse_cursor_from_url(url: str) -> Tuple[int, str, str]:
    m = re.search(r"/(\d+)$", url.strip())
    if m:
        return int(m.group(1)), url[: m.start(1)], url[m.end(1):]
    if url.endswith("/"):
        url0 = url + "0"
    else:
        url0 = url + "/0"
    m = re.search(r"/(\d+)$", url0)
    return int(m.group(1)), url0[: m.start(1)], url0[m.end(1):]

def fetch_page(url: str) -> Tuple[List[dict], Optional[int]]:
    data = load_json_from_url(url)
    msgs = data.get("messages", [])
    col = data.get("collection", []) or []
    total = None
    if msgs:
        t = msgs[0].get("total")
        try:
            total = int(t) if t is not None else None
        except Exception:
            total = None
    return col, total

def fetch_all_pages_step(base_url: str, log_fn=print, stop_event: Optional[threading.Event] = None) -> Tuple[List[dict], int]:
    cursor0, head, tail = parse_cursor_from_url(base_url)

    url0 = f"{head}{cursor0}{tail}"
    log_fn(f"[INFO] Fetching cursor={cursor0}: {url0}")
    col0, total = fetch_page(url0)

    if total is None:
        total = len(col0)
        log_fn(f"[INFO] total (fallback) = {total}")
    else:
        log_fn(f"[INFO] total = {total}")

    records: List[dict] = []
    records.extend(col0)

    next_cursors = list(range(((cursor0 // 100) + 1) * 100, total, 100))
    for cur in next_cursors:
        if stop_event and stop_event.is_set():
            log_fn("[INFO] Stop requested. Abort paging.")
            break
        url = f"{head}{cur}{tail}"
        log_fn(f"[INFO] Fetching cursor={cur}: {url}")
        col, _ = fetch_page(url)
        records.extend(col)
        if len(col) < 100:
            break

    log_fn(f"[INFO] collected (raw) = {len(records)}")
    return records, total

# ============================
# LM Studio (OpenAI互換) 呼出
# ============================
def clean_code_fence(text: str) -> str:
    text = text.strip()
    if text.startswith("```"):
        text = re.sub(r"^```[a-zA-Z0-9]*\s*", "", text, flags=re.DOTALL)
        text = re.sub(r"\s*```$", "", text, flags=re.DOTALL)
    return text.strip()

def parse_json_safe(text: str) -> Optional[dict]:
    text = clean_code_fence(text)
    try:
        return json.loads(text)
    except Exception:
        m = re.search(r"\{.*\}", text, flags=re.DOTALL)
        if m:
            try:
                return json.loads(m.group(0))
            except Exception:
                return None
    return None

def translate_title_abstract_ja(title_en: str, abstract_en: str,
                                lm_url: str, lm_model: str,
                                log_fn=print) -> Tuple[str, str]:
    messages = [
        {
            "role": "system",
            "content": (
                "You are a professional scientific translator. "
                "Translate the given English title and abstract into natural, precise Japanese for researchers. "
                "Return ONLY valid JSON with keys: title_ja, abstract_ja. No extra text."
            ),
        },
        {
            "role": "user",
            "content": (
                "Translate to Japanese (ja). Output strictly JSON.\n"
                "{\n"
                f'  "title": {json.dumps(title_en, ensure_ascii=False)},\n'
                f'  "abstract": {json.dumps(abstract_en, ensure_ascii=False)}\n'
                "}"
            ),
        },
    ]

    payload = {
        "model": lm_model,
        "messages": messages,
        "temperature": LM_TEMPERATURE,
    }

    for attempt in range(1, LM_MAX_RETRY + 1):
        try:
            resp = requests.post(lm_url, json=payload, timeout=TIMEOUT_SEC)
            resp.raise_for_status()
            data = resp.json()
            content = data["choices"][0]["message"]["content"]
            parsed = parse_json_safe(content)
            if parsed and "title_ja" in parsed and "abstract_ja" in parsed:
                return str(parsed["title_ja"]).strip(), str(parsed["abstract_ja"]).strip()
        except Exception as e:
            log_fn(f"[LM] attempt {attempt}/{LM_MAX_RETRY} failed: {e}")
            time.sleep(1.2)

    log_fn("[LM] fallback to original text")
    return title_en, abstract_en

# ==============
# HTML 生成関数
# ==============
def build_paper_html(record: dict, title_ja: str, abstract_ja: str,
                     doidate: str, doino: str) -> str:
    title_en = html_escape_or_none(record.get("title"))
    abstract_en = html_escape_or_none(record.get("abstract"))
    date = html_escape_or_none(record.get("date"))
    category_display = html_escape_or_none(record.get("category"))
    server = html_escape_or_none(record.get("server"))
    doi_raw = html_escape_or_none(record.get("doi"))
    doi_url_full = f"https://doi.org/{record.get('doi','')}"
    doi_1101 = doi_parts_to_1101_url(doidate, doino)
    jats = record.get("jatsxml")
    jats_line = (
        f'<div><strong>JATS XML:</strong> <a href="{escape(jats)}" target="_blank" rel="noopener">{escape(jats)}</a></div>'
        if jats else ""
    )

    return HTML_DOC_TPL.format(
        title=escape(f"{category_display} | {date} | {doino}"),
        title_ja=escape(title_ja),
        title_en=title_en,
        date=date,
        category=category_display,
        server=server,
        doi_1101_url=escape(doi_1101),
        doi_url=escape(doi_url_full),
        doi_raw=doi_raw,
        jats_line=jats_line,
        abstract_ja=escape(abstract_ja),
        abstract_en=abstract_en,
    )

def process_record(base_dir: Path, rec: dict, total: int, index: int,
                   lm_url: str, lm_model: str, log_fn=print):
    doi = rec.get("doi") or ""
    date = rec.get("date") or ""
    category_display = rec.get("category") or "uncategorized"
    cat_slug = slugify_category(category_display)

    try:
        doidate, doino = extract_doi_parts(doi)
        prog_note = doino
    except Exception:
        doidate, doino = "unknown", "unknown"
        prog_note = doi

    log_fn(f"[PROC] {index}/{total}  doi/doidate/doino: {prog_note}")

    title_en = rec.get("title") or ""
    abstract_en = rec.get("abstract") or ""
    title_ja, abstract_ja = translate_title_abstract_ja(title_en, abstract_en, lm_url, lm_model, log_fn)

    paper_rel = Path("date") / date / cat_slug / doidate / f"{doino}.html"
    paper_path = base_dir / paper_rel
    html = build_paper_html(rec, title_ja, abstract_ja, doidate, doino)
    write_text(paper_path, html)

    date_dir = base_dir / "date" / date
    date_index = date_dir / "date.html"
    ensure_index_file(
        date_index,
        title=f"Index for {date}",
        subtitle=f"日付 {date} の一覧",
        header_cols=["doino", "doidate", "local", "doi", "category"],
    )
    local_link_for_date = f"./{cat_slug}/{doidate}/{doino}.html"
    rowid = make_row_id(date, category_display, doidate, doino)
    append_row_if_absent(
        date_index,
        build_index_row(date, category_display, doidate, doino, local_link_for_date, doi_parts_to_1101_url(doidate, doino)),
        rowid=rowid,
    )

    date_cat_dir = date_dir / cat_slug
    date_cat_index = date_cat_dir / "category.html"
    ensure_index_file(
        date_cat_index,
        title=f"Category '{category_display}' on {date}",
        subtitle=f"{date} のカテゴリ {category_display} 集約",
        header_cols=["doino", "doidate", "local", "doi", "category"],
    )
    local_link_for_date_cat = f"./{doidate}/{doino}.html"
    append_row_if_absent(
        date_cat_index,
        build_index_row(date, category_display, doidate, doino, local_link_for_date_cat, doi_parts_to_1101_url(doidate, doino)),
        rowid=rowid,
    )

    global_cat_dir = base_dir / "category" / cat_slug
    global_cat_index = global_cat_dir / "category.html"
    ensure_index_file(
        global_cat_index,
        title=f"Category '{category_display}' (All Dates)",
        subtitle=f"カテゴリ {category_display} の全日付集約",
        header_cols=["doino", "doidate", "local", "doi", "category"],
    )
    local_link_for_global_cat = f"../../date/{date}/{cat_slug}/{doidate}/{doino}.html"
    append_row_if_absent(
        global_cat_index,
        build_index_row(date, category_display, doidate, doino, local_link_for_global_cat, doi_parts_to_1101_url(doidate, doino)),
        rowid=rowid,
    )

# ============
# GUI本体
# ============
class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("bioRxiv / medRxiv Daily → JA & HTML Generator")
        self.geometry("1160x820")

        self.stop_now_event = threading.Event()
        self.stop_after_day_event = threading.Event()
        self.worker_thread = None

        frm = ttk.Frame(self, padding=10)
        frm.pack(fill="x")

        # スタイル（ナビボタンを大きく）
        self.style = ttk.Style(self)
        self.style.configure("NavHuge.TButton", font=("Segoe UI", 12, "bold"), padding=(12, 8))

        ttk.Label(frm, text="Server:").grid(row=0, column=0, sticky="w")
        self.server_var = tk.StringVar(value=DEFAULT_SERVER)
        self.server_cb = ttk.Combobox(frm, textvariable=self.server_var, values=["biorxiv", "medrxiv"], width=12, state="readonly")
        self.server_cb.grid(row=0, column=1, sticky="w", padx=(5,10))

        ttk.Label(frm, text="Date (YYYY-MM-DD):").grid(row=0, column=2, sticky="w")
        self.date_var = tk.StringVar()
        if HAS_TKCALENDAR:
            self.date_entry = DateEntry(frm, textvariable=self.date_var, date_pattern="yyyy-mm-dd", width=14)
        else:
            self.date_entry = ttk.Entry(frm, textvariable=self.date_var, width=16)
            self.date_var.set("2025-10-17")
        self.date_entry.grid(row=0, column=3, sticky="w", padx=(5,10))

        # 期間指定
        ttk.Label(frm, text="Period:").grid(row=0, column=4, sticky="e")
        self.period_var = tk.StringVar(value="Day")
        self.period_cb = ttk.Combobox(frm, textvariable=self.period_var, values=list(PERIOD_MAP.keys()), width=8, state="readonly")
        self.period_cb.grid(row=0, column=5, sticky="w", padx=(5,10))

        # 物理ナビ（◀年 ◀月 ◀日 ▶日 ▶月 ▶年）
        self.nav_year_prev = ttk.Button(frm, text="◀年", style="NavHuge.TButton", width=4, command=lambda: self.shift_date(years=-1))
        self.nav_month_prev = ttk.Button(frm, text="◀月", style="NavHuge.TButton", width=4, command=lambda: self.shift_date(months=-1))
        self.nav_day_prev = ttk.Button(frm, text="◀日", style="NavHuge.TButton", width=4, command=lambda: self.shift_date(days=-1))
        self.nav_day_next = ttk.Button(frm, text="▶日", style="NavHuge.TButton", width=4, command=lambda: self.shift_date(days=+1))
        self.nav_month_next = ttk.Button(frm, text="▶月", style="NavHuge.TButton", width=4, command=lambda: self.shift_date(months=+1))
        self.nav_year_next = ttk.Button(frm, text="▶年", style="NavHuge.TButton", width=4, command=lambda: self.shift_date(years=+1))
        self.nav_year_prev.grid(row=1, column=2, padx=(0,4), pady=(4,6), sticky="w")
        self.nav_month_prev.grid(row=1, column=3, padx=(0,4), pady=(4,6), sticky="w")
        self.nav_day_prev.grid(row=1, column=4, padx=(0,8), pady=(4,6), sticky="w")
        self.nav_day_next.grid(row=1, column=5, padx=(0,4), pady=(4,6), sticky="w")
        self.nav_month_next.grid(row=1, column=6, padx=(0,4), pady=(4,6), sticky="w")
        self.nav_year_next.grid(row=1, column=7, padx=(0,10), pady=(4,6), sticky="w")

        ttk.Label(frm, text="Base Dir:").grid(row=2, column=0, sticky="w")
        self.base_dir_var = tk.StringVar(value=str(Path(".").resolve()))
        self.base_dir_entry = ttk.Entry(frm, textvariable=self.base_dir_var, width=60)
        self.base_dir_entry.grid(row=2, column=1, columnspan=5, sticky="we", padx=(5,5))
        ttk.Button(frm, text="Browse...", command=self.browse_dir).grid(row=2, column=6, sticky="w", padx=(5,0))

        ttk.Label(frm, text="LM URL:").grid(row=3, column=0, sticky="w")
        self.lm_url_var = tk.StringVar(value=LMSTUDIO_API_URL_DEFAULT)
        ttk.Entry(frm, textvariable=self.lm_url_var, width=40).grid(row=3, column=1, sticky="w", padx=(5,10))

        ttk.Label(frm, text="LM Model:").grid(row=3, column=2, sticky="w")
        self.lm_model_var = tk.StringVar(value=LMSTUDIO_MODEL_DEFAULT)
        ttk.Entry(frm, textvariable=self.lm_model_var, width=30).grid(row=3, column=3, sticky="w", padx=(5,10))

        ttk.Label(frm, text="Keywords (comma-separated):").grid(row=4, column=0, sticky="w")
        self.kw_var = tk.StringVar()
        ttk.Entry(frm, textvariable=self.kw_var, width=50).grid(row=4, column=1, columnspan=3, sticky="we", padx=(5,10))
        ttk.Label(frm, text="Mode:").grid(row=4, column=4, sticky="e")
        self.kw_mode_var = tk.StringVar(value="OR")
        ttk.Combobox(frm, textvariable=self.kw_mode_var, values=["OR", "AND"], width=6, state="readonly").grid(row=4, column=5, sticky="w")

        self.run_btn = ttk.Button(frm, text="Fetch & Generate", command=self.on_run)
        self.run_btn.grid(row=0, column=7, sticky="w", padx=(5,0))
        self.stop_now_btn = ttk.Button(frm, text="Stop Now", command=self.on_stop_now, state="disabled")
        self.stop_now_btn.grid(row=3, column=7, sticky="w", padx=(5,0))
        self.stop_after_day_btn = ttk.Button(frm, text="Stop After This Day", command=self.on_stop_after_day, state="disabled")
        self.stop_after_day_btn.grid(row=4, column=7, sticky="w", padx=(5,0))

        prf = ttk.Frame(self, padding=(10,0,10,5))
        prf.pack(fill="x")
        self.progress = ttk.Progressbar(prf, orient="horizontal", mode="determinate", maximum=100)
        self.progress.pack(fill="x", pady=(5,2))
        self.prog_lbl = ttk.Label(prf, text="Progress: -/-")
        self.prog_lbl.pack(anchor="w")

        lgf = ttk.LabelFrame(self, text="Logs", padding=8)
        lgf.pack(fill="both", expand=True, padx=10, pady=5)
        self.log_text = ScrolledText(lgf, height=18, font=("Consolas", 10))
        self.log_text.pack(fill="both", expand=True)

        btm = ttk.LabelFrame(self, text="Open Index", padding=8)
        btm.pack(fill="x", padx=10, pady=5)

        ttk.Label(btm, text="Category (slug):").grid(row=0, column=0, sticky="w")
        self.cat_list_var = tk.StringVar()
        self.cat_cb = ttk.Combobox(btm, textvariable=self.cat_list_var, width=30, state="readonly")
        self.cat_cb.grid(row=0, column=1, sticky="w", padx=(5,10))
        ttk.Button(btm, text="Refresh", command=self.refresh_category_list).grid(row=0, column=2, sticky="w", padx=(0,10))
        ttk.Button(btm, text="Open Selected Category Index", command=self.open_selected_category_index).grid(row=0, column=3, sticky="w")

        ttk.Label(btm, text="Date:").grid(row=1, column=0, sticky="w")
        ttk.Button(btm, text="Open Selected Date Index", command=self.open_selected_date_index).grid(row=1, column=1, sticky="w")
        ttk.Button(btm, text="Open All Dates Index", command=self.open_all_dates_index).grid(row=1, column=2, sticky="w")

        opf = ttk.Frame(self, padding=10)
        opf.pack(fill="x")
        self.open_btn = ttk.Button(opf, text="Open Output Folder", command=self.open_output_folder, state="normal")
        self.open_btn.pack(side="left")

        frm.columnconfigure(3, weight=1)

        if not HAS_TKCALENDAR:
            self.log("[INFO] tkcalendar が見つかりませんでした。日付は YYYY-MM-DD の形式で手入力してください。")
        self.refresh_category_list()

    def shift_date(self, years=0, months=0, days=0):
        try:
            y, m, d = [int(x) for x in self.date_var.get().split("-")]
            cur = ddate(y, m, d)
        except Exception:
            cur = ddate.today()
        total_months = cur.month - 1 + months + years * 12
        new_year = cur.year + total_months // 12
        new_month = total_months % 12 + 1
        new_date = cur + timedelta(days=days)
        if months or years:
            last_day = calendar.monthrange(new_year, new_month)[1]
            day = min(cur.day, last_day)
            new_date = ddate(new_year, new_month, day)
        self.date_var.set(new_date.strftime("%Y-%m-%d"))

    def log(self, msg: str):
        self.log_text.insert("end", msg + "\n")
        self.log_text.see("end")
        self.update_idletasks()

    def browse_dir(self):
        d = filedialog.askdirectory(initialdir=self.base_dir_var.get())
        if d:
            self.base_dir_var.set(d)

    def open_output_folder(self):
        p = Path(self.base_dir_var.get()).resolve()
        if p.exists():
            if sys.platform.startswith("win"):
                os.startfile(str(p))
            elif sys.platform == "darwin":
                os.system(f'open "{p}"')
            else:
                os.system(f'xdg-open "{p}"')
        else:
            messagebox.showerror("Error", f"Folder not found: {p}")

    def set_running(self, running: bool):
        self.run_btn.config(state="disabled" if running else "normal")
        self.stop_now_btn.config(state="normal" if running else "disabled")
        self.stop_after_day_btn.config(state="normal" if running else "disabled")
        state = "disabled" if running else "normal"
        for w in (self.cat_cb, self.period_cb):
            w.config(state="readonly" if state == "normal" else "disabled")

    def refresh_category_list(self):
        base_dir = Path(self.base_dir_var.get()).resolve()
        cats_dir = base_dir / "category"
        items = []
        if cats_dir.exists():
            for p in sorted(cats_dir.iterdir()):
                if p.is_dir():
                    items.append(p.name)
        self.cat_cb["values"] = items
        if items:
            self.cat_list_var.set(items[0])

    def open_selected_category_index(self):
        base_dir = Path(self.base_dir_var.get()).resolve()
        slug = (self.cat_list_var.get() or "").strip()
        if not slug:
            messagebox.showwarning("No category", "カテゴリが見つかりません。Refresh を試してください。")
            return
        path = base_dir / "category" / slug / "category.html"
        self._open_file(path)

    def open_selected_date_index(self):
        base_dir = Path(self.base_dir_var.get()).resolve()
        date = (self.date_var.get() or "").strip()
        if not re.match(r"^\d{4}-\d{2}-\d{2}$", date):
            messagebox.showerror("Invalid date", "日付は YYYY-MM-DD の形式で入力してください。")
            return
        path = base_dir / "date" / date / "date.html"
        self._open_file(path)

    def open_all_dates_index(self):
        base_dir = Path(self.base_dir_var.get()).resolve()
        path = base_dir / "date" / "all_date.html"
        self._open_file(path)

    def _open_file(self, path: Path):
        if not path.exists():
            messagebox.showerror("Not found", f"ファイルが見つかりません:\n{path}")
            return
        if sys.platform.startswith("win"):
            os.startfile(str(path))
        elif sys.platform == "darwin":
            os.system(f'open "{path}"')
        else:
            os.system(f'xdg-open "{path}"')

    def on_stop_now(self):
        if self.worker_thread and self.worker_thread.is_alive():
            self.stop_now_event.set()
            self.log("[INFO] Stop Now 要求を送信しました。")

    def on_stop_after_day(self):
        if self.worker_thread and self.worker_thread.is_alive():
            self.stop_after_day_event.set()
            self.log("[INFO] Stop After This Day 要求を送信しました。")

    def on_run(self):
        server = self.server_var.get().strip()
        start_date_str = self.date_var.get().strip()
        base_dir = Path(self.base_dir_var.get()).resolve()
        lm_url = self.lm_url_var.get().strip()
        lm_model = self.lm_model_var.get().strip()
        period = self.period_var.get()

        if not re.match(r"^\d{4}-\d{2}-\d{2}$", start_date_str):
            messagebox.showerror("Invalid date", "日付は YYYY-MM-DD の形式で入力してください。")
            return
        days = PERIOD_MAP.get(period, 1)

        raw_kws = self.kw_var.get()
        kws = [k.strip() for k in raw_kws.split(",") if k.strip()]
        mode = (self.kw_mode_var.get() or "OR").upper()
        if mode not in ("OR", "AND"):
            mode = "OR"

        self.set_running(True)
        self.stop_now_event.clear()
        self.stop_after_day_event.clear()
        self.progress.config(value=0, maximum=100)
        self.prog_lbl.config(text="Progress: -/-")
        self.log_text.delete("1.0", "end")
        self.log(f"[START] server={server}, start_date={start_date_str}, period={period}({days} days), base_dir={base_dir}")
        if kws:
            self.log(f"[FILTER] keywords={kws} mode={mode}")

        try:
            y, m, d = [int(x) for x in start_date_str.split("-")]
            start_date = ddate(y, m, d)
        except Exception:
            messagebox.showerror("Invalid date", "日付の解析に失敗しました。")
            self.set_running(False)
            return
        dates = [(start_date - timedelta(days=offset)).strftime("%Y-%m-%d") for offset in range(days)]

        def matches_keywords(record: dict) -> bool:
            if not kws:
                return True
            text = ((record.get("title") or "") + " " + (record.get("abstract") or "")).lower()
            flags = [(kw.lower() in text) for kw in kws]
            return all(flags) if mode == "AND" else any(flags)

        def worker():
            try:
                for di, day_str in enumerate(dates, start=1):
                    if self.stop_now_event.is_set():
                        self.log("[INFO] Stop Now: 期間処理を中断します。")
                        break

                    self.log(f"[DAY] {di}/{len(dates)}  Target date = {day_str}")
                    url = f"{DEFAULT_API_BASE}/{server}/{day_str}/{day_str}/0"

                    records, total_api = fetch_all_pages_step(url, log_fn=self.log, stop_event=self.stop_now_event)
                    if self.stop_now_event.is_set():
                        self.log("[INFO] Stop Now: 当日処理を開始前に中断。")
                        break

                    if not records:
                        self.log("[INFO] 収集対象なし（collection 空）")
                        update_all_date_index(base_dir, day_str, collected=0)
                        update_month_log(base_dir, day_str, collected=0)
                        update_year_log(base_dir, day_str)
                        if self.stop_after_day_event.is_set():
                            self.log("[INFO] Stop After This Day: 当日が空のためそのまま終了します。")
                            break
                        continue

                    filtered = [r for r in records if matches_keywords(r)]
                    self.log(f"[FILTER] matched = {len(filtered)} / raw = {len(records)} for {day_str}")
                    total = len(filtered)

                    if total == 0:
                        self.log("[INFO] キーワード一致なし。ログのみ更新します。")
                        update_all_date_index(base_dir, day_str, collected=0)
                        update_month_log(base_dir, day_str, collected=0)
                        update_year_log(base_dir, day_str)
                        if self.stop_after_day_event.is_set():
                            self.log("[INFO] Stop After This Day: 当日の処理完了（ゼロ件）。終了します。")
                            break
                        continue

                    self.progress.config(value=0, maximum=max(1, total))
                    self.prog_lbl.config(text=f"Day {di}/{len(dates)} — Progress: 0/{total}")

                    processed = 0
                    for i, rec in enumerate(filtered, start=1):
                        if self.stop_now_event.is_set():
                            self.log("[INFO] Stop Now: 当日処理を中断します。")
                            break
                        try:
                            process_record(base_dir, rec, total=total, index=i,
                                           lm_url=lm_url, lm_model=lm_model, log_fn=self.log)
                            processed += 1
                        except Exception as e:
                            self.log(f"[WARN] 1件処理失敗: {e}")
                        self.progress.config(value=i)
                        self.prog_lbl.config(text=f"Day {di}/{len(dates)} — Progress: {i}/{total}")
                        self.update_idletasks()

                    update_all_date_index(base_dir, day_str, collected=processed)
                    update_month_log(base_dir, day_str, collected=processed)
                    update_year_log(base_dir, day_str)

                    if self.stop_after_day_event.is_set():
                        self.log("[INFO] Stop After This Day: 当日の処理完了を確認。終了します。")
                        break

                self.log("[DONE] 期間処理が終了しました。")
            except Exception as e:
                self.log(f"[ERROR] {e}")
            finally:
                self.set_running(False)
                self.refresh_category_list()

        self.worker_thread = threading.Thread(target=worker, daemon=True)
        self.worker_thread.start()

# ---- 実行 ----
if __name__ == "__main__":
    App().mainloop()
